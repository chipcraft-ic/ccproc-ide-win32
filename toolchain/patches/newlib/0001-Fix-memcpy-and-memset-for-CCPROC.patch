From eb8cf5fbe3e5c1faa06c000da4f2132c3b58cb50 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Rafa=C5=82=20Harabie=C5=84?= <rafalh1992@o2.pl>
Date: Fri, 28 Jul 2017 16:16:13 +0200
Subject: Fix memcpy and memset for CCPROC.

---
 newlib/configure.host                |   3 +-
 newlib/libc/machine/mips/Makefile.in |  14 +--
 newlib/libc/machine/mips/memcpy.c    | 164 +++++++++++++++++++++++++++
 newlib/libc/machine/mips/memset.S    |   8 ++
 4 files changed, 181 insertions(+), 8 deletions(-)
 create mode 100644 newlib/libc/machine/mips/memcpy.c

diff --git a/newlib/configure.host b/newlib/configure.host
index d471200..493d7b0 100644
--- a/newlib/configure.host
+++ b/newlib/configure.host
@@ -755,7 +755,8 @@ case "${host}" in
 	;;
   mips*-*-elf*)
 	default_newlib_io_long_long="yes"
-	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	syscall_dir=syscalls
+	newlib_cflags="${newlib_cflags} -DNO_UNALIGNED_LOADSTORE"
 	;;
   mmix-*)
 	syscall_dir=syscalls
diff --git a/newlib/libc/machine/mips/Makefile.in b/newlib/libc/machine/mips/Makefile.in
index b2d729e..053c7de 100644
--- a/newlib/libc/machine/mips/Makefile.in
+++ b/newlib/libc/machine/mips/Makefile.in
@@ -197,7 +197,7 @@ AUTOMAKE_OPTIONS = cygnus
 INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
-lib_a_SOURCES = setjmp.S strlen.c strcmp.S strncpy.c memset.S memcpy.S
+lib_a_SOURCES = setjmp.S strlen.c strcmp.S strncpy.c memset.S memcpy.c
 lib_a_CCASFLAGS = $(AM_CCASFLAGS) -D_COMPILING_NEWLIB
 lib_a_CFLAGS = $(AM_CFLAGS) -D_COMPILING_NEWLIB
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
@@ -278,12 +278,6 @@ lib_a-memset.o: memset.S
 lib_a-memset.obj: memset.S
 	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-memset.obj `if test -f 'memset.S'; then $(CYGPATH_W) 'memset.S'; else $(CYGPATH_W) '$(srcdir)/memset.S'; fi`
 
-lib_a-memcpy.o: memcpy.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-memcpy.o `test -f 'memcpy.S' || echo '$(srcdir)/'`memcpy.S
-
-lib_a-memcpy.obj: memcpy.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-memcpy.obj `if test -f 'memcpy.S'; then $(CYGPATH_W) 'memcpy.S'; else $(CYGPATH_W) '$(srcdir)/memcpy.S'; fi`
-
 .c.o:
 	$(COMPILE) -c $<
 
@@ -302,6 +296,12 @@ lib_a-strncpy.o: strncpy.c
 lib_a-strncpy.obj: strncpy.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-strncpy.obj `if test -f 'strncpy.c'; then $(CYGPATH_W) 'strncpy.c'; else $(CYGPATH_W) '$(srcdir)/strncpy.c'; fi`
 
+lib_a-memcpy.o: memcpy.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-memcpy.o `test -f 'memcpy.c' || echo '$(srcdir)/'`memcpy.c
+
+lib_a-memcpy.obj: memcpy.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-memcpy.obj `if test -f 'memcpy.c'; then $(CYGPATH_W) 'memcpy.c'; else $(CYGPATH_W) '$(srcdir)/memcpy.c'; fi`
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
diff --git a/newlib/libc/machine/mips/memcpy.c b/newlib/libc/machine/mips/memcpy.c
new file mode 100644
index 0000000..8f5a31c
--- /dev/null
+++ b/newlib/libc/machine/mips/memcpy.c
@@ -0,0 +1,164 @@
+/*
+FUNCTION
+        <<memcpy>>---copy memory regions, optimized for the mips processors
+
+ANSI_SYNOPSIS
+        #include <string.h>
+        void* memcpy(void *<[out]>, const void *<[in]>, size_t <[n]>);
+
+TRAD_SYNOPSIS
+        void *memcpy(<[out]>, <[in]>, <[n]>
+        void *<[out]>;
+        void *<[in]>;
+        size_t <[n]>;
+
+DESCRIPTION
+        This function copies <[n]> bytes from the memory region
+        pointed to by <[in]> to the memory region pointed to by
+        <[out]>.
+
+        If the regions overlap, the behavior is undefined.
+
+RETURNS
+        <<memcpy>> returns a pointer to the first byte of the <[out]>
+        region.
+
+PORTABILITY
+<<memcpy>> is ANSI C.
+
+<<memcpy>> requires no supporting OS subroutines.
+
+QUICKREF
+        memcpy ansi pure
+      */
+
+#include <_ansi.h>
+#include <stddef.h>
+#include <limits.h>
+
+#ifdef __mips64
+#define wordtype long long
+#else
+#define wordtype long
+#endif
+
+/* Nonzero if either X or Y is not aligned on a "long" boundary.  */
+#define UNALIGNED(X, Y) \
+  (((long)X & (sizeof (wordtype) - 1)) | ((long)Y & (sizeof (wordtype) - 1)))
+
+/* How many bytes are copied each iteration of the 4X unrolled loop.  */
+#define BIGBLOCKSIZE    (sizeof (wordtype) << 2)
+
+/* How many bytes are copied each iteration of the word copy loop.  */
+#define LITTLEBLOCKSIZE (sizeof (wordtype))
+
+/* Threshhold for punting to the byte copier.  */
+#define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
+
+_PTR
+_DEFUN (memcpy, (dst0, src0, len0),
+      _PTR dst0 _AND
+      _CONST _PTR src0 _AND
+      size_t len0)
+{
+#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__) || defined(__mips16)
+  char *dst = (char *) dst0;
+  char *src = (char *) src0;
+
+  _PTR save = dst0;
+
+  while (len0--)
+    {
+      *dst++ = *src++;
+    }
+
+  return save;
+#else
+  char *dst = dst0;
+  _CONST char *src = src0;
+  wordtype *aligned_dst;
+  _CONST wordtype *aligned_src;
+  int   len =  len0;
+  size_t iter;
+
+  /* Handle aligned moves here.  */
+  if (!UNALIGNED (src, dst))
+    {
+      iter = len / BIGBLOCKSIZE;
+      len = len % BIGBLOCKSIZE;
+      aligned_dst = (wordtype *)dst;
+      aligned_src = (wordtype *)src;
+
+        /* Copy 4X long or long long words at a time if possible.  */
+      while (iter > 0)
+      {
+        wordtype tmp0 = aligned_src[0];
+        wordtype tmp1 = aligned_src[1];
+        wordtype tmp2 = aligned_src[2];
+        wordtype tmp3 = aligned_src[3];
+
+        aligned_dst[0] = tmp0;
+        aligned_dst[1] = tmp1;
+        aligned_dst[2] = tmp2;
+        aligned_dst[3] = tmp3;
+        aligned_src += 4;
+        aligned_dst += 4;
+        iter--;
+      }
+
+      /* Copy one long or long long word at a time if possible.  */
+      iter = len / LITTLEBLOCKSIZE;
+      len = len % LITTLEBLOCKSIZE;
+
+      while (iter > 0)
+      {
+        *aligned_dst++ = *aligned_src++;
+        iter--;
+      }
+
+      /* Pick up any residual with a byte copier.  */
+      dst = (char*)aligned_dst;
+      src = (char*)aligned_src;
+
+      while (len > 0)
+      {
+        *dst++ = *src++;
+        len--;
+      }
+
+      return dst0;
+    }
+
+  /* Handle unaligned moves here, using lwr/lwl and swr/swl where possible */
+  else
+    {
+#ifndef NO_UNALIGNED_LOADSTORE
+      int tmp;
+      int *int_src = (int *)src;
+      int *int_dst = (int *)dst;
+      iter = len / 4;
+      len = len % 4;
+      while (iter > 0)
+      {
+        __asm__ ("ulw %0,%1" : "=r" (tmp) : "m" (*int_src));
+        iter--;
+        int_src++;
+        __asm__ ("usw %1,%0" : "=m" (*int_dst) : "r" (tmp));
+        int_dst++;
+      }
+
+      /* Pick up any residual with a byte copier.  */
+      dst = (char*)int_dst;
+      src = (char*)int_src;
+#endif
+
+      while (len > 0)
+      {
+        *dst++ = *src++;
+        len--;
+      }
+
+      return dst0;
+    }
+#endif /* not PREFER_SIZE_OVER_SPEED */
+}
diff --git a/newlib/libc/machine/mips/memset.S b/newlib/libc/machine/mips/memset.S
index 565fc7e..9437819 100644
--- a/newlib/libc/machine/mips/memset.S
+++ b/newlib/libc/machine/mips/memset.S
@@ -264,8 +264,16 @@ L(set0):
 	andi	t2,a3,(NSIZE-1)		/* word-unaligned address?          */
 	beq	t2,zero,L(aligned)	/* t2 is the unalignment count      */
 	PTR_SUBU a2,a2,t2
+# ifndef NO_UNALIGNED_LOADSTORE
 	C_STHI	a1,0(a0)
 	PTR_ADDU a0,a0,t2
+# else
+L(loop_align):
+	PTR_SUBU t2, t2, 1
+	sb a1,0(a0)
+	bne	t2,zero,L(loop_align)
+	PTR_ADDU a0, a0, 1
+# endif
 #else /* R6_CODE */
 	andi	t2,a0,(NSIZE-1)
 	lapc	t9,L(atable)
-- 
2.17.1

